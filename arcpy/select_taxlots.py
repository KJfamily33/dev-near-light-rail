# Copyright: (c) Grant Humphries for TriMet, 2013
# ArcGIS Version:   10.2
# Python Version:   2.7.3
#--------------------------------

import os
import re
import csv
import arcpy
from arcpy import env

# Allow shapefiles to be overwritten and set the current workspace
env.overwriteOutput = True
env.addOutputsToMap = True
# BE SURE TO UPDATE THIS FILE PATH TO THE NEW FOLDER EACH TIME A NEW ANALYSIS IS RUN!!!
env.workspace = '//gisstore/gis/PUBLIC/GIS_Projects/Development_Around_Lightrail/data/2013_12'

# Creates a 'temp' sub-folder to store temporary project output if it doesn't already exist
if not os.path.exists(os.path.join(env.workspace, 'temp')):
	os.makedirs(os.path.join(env.workspace, 'temp'))

# Add project data
isocrones = os.path.join(env.workspace, 'rail_stop_isocrones.shp')
taxlots = '//gisstore/gis/RLIS/TAXLOTS/taxlots.shp'
multi_family = '//gisstore/gis/RLIS/LAND/multifamily_housing_inventory.shp'

# Taxlots will need to be selected based on their location relative to isocrones, the attributes of the
# isocrones that they fall within, and their own attributes, thus a spatial join will be performed
# so that all of the pertainent information will be contained within a single dataset
def mergeTaxlotsIsocrones(tl_data, name, dissolve_fields, unique_id, accrual_unit):
	taxlot_iso_join = os.path.join(env.workspace, 'temp/' + name + '_iso_join.shp')
	join_operation = 'Join_One_to_Many'
	join_type = 'Keep_Common'
	arcpy.SpatialJoin_analysis(tl_data, isocrones, taxlot_iso_join, join_operation, join_type)

	taxlot_iso_dissolve = os.path.join(env.workspace, 'temp/' + name + '_iso_dissolve.shp')
	dissolve_fields.append('max_zone')
	stats_fields = [['incpt_year', 'MIN']]
	part_type = 'Single_Part'
	arcpy.Dissolve_management(taxlot_iso_join, taxlot_iso_dissolve, dissolve_fields, stats_fields, 
								part_type)

	# Remove any taxlots that have yearbuilt date before the inception year of the MAX stop
	# isocrone that has been joined to it as this construction wasn't influenced by MAX development
	compare_fields = ['YEARBUILT', 'MIN_incpt_']
	with arcpy.da.UpdateCursor(taxlot_iso_dissolve, compare_fields) as cursor:
		for build_year, incept_year in cursor:
			if build_year < incept_year:
				cursor.deleteRow()

	# Sum the accural units for each MAX zone as well as the for all zones combined, there will be no
	# double counting in the latter, even though some zones share common taxlots
	id_list = []
	global am_label
	am_label = 'All MAX'
	zone_dict = {am_label: 0}
	fields = [unique_id, 'max_zone', accrual_unit]
	with arcpy.da.SearchCursor(taxlot_iso_dissolve, fields) as cursor:
		for uid, zone, unit in cursor:
			if zone not in zone_dict:
				zone_dict[zone] = unit
			else:
				zone_dict[zone] += unit

			if uid not in id_list:
				zone_dict[am_label] += unit
				id_list.append(uid)

	return zone_dict

# Run function for taxlot data, attributes that are to be retained must be included in the dissolve
# field list, running this function on the taxlots file takes about 11 minutes because it is very
# large file, but things should speed up thereafter
tl_name = 'taxlot'
tl_dissolve_fields = ['TLID', 'SITEADDR', 'SITECITY', 'SITEZIP', 'LANDVAL', 'BLDGVAL', 'TOTALVAL', 
						'BLDGSQFT', 'YEARBUILT', 'PROP_CODE', 'LANDUSE', 'SALEDATE', 'SALEPRICE', 'COUNTY']
tl_id = 'TLID'
tl_unit = 'TOTALVAL'
tl_stats = mergeTaxlotsIsocrones(taxlots, tl_name, tl_dissolve_fields, tl_id, tl_unit)

# Run the function for multi-familty housing data
mf_name = 'multifam'
mf_dissolve_fields = ['ADDRESS', 'MAIL_CITY', 'UNITS', 'ZIPCODE', 'UNIT_TYPE', 'COUNTY', 'MIXED_USE',
						 'YEARBUILT', 'COMMONNAME', 'DATASOURCE', 'CONFIDENCE', 'METRO_ID']
mf_id = 'METRO_ID'
mf_unit = 'UNITS'
mf_stats = mergeTaxlotsIsocrones(multi_family, mf_name, mf_dissolve_fields, mf_id, mf_unit)

# Combine format the stats that were generated by the function above in a list such that they 
# can be written neatly to a csv
stats = []
for key in tl_stats:
	stats.append((key, tl_stats[key], mf_stats[key]))

# Sort the stats by group name
stats.sort(key=lambda (group, taxlots, multifam): group)

# Find the index location of the 'total' group and move it to the last position in the list
for index, tup in list(enumerate(stats)):
	if am_label in tup:
		am_index = index
		break
stats.insert(len(stats), stats.pop(am_index))

# Add a header tuple to the first position in the list
header = ('Group', 'Total Taxlot Value', 'Multi-Family Units')
stats.insert(0, header)

# Creates a 'csv' sub-folder to store stats ouput if it doesn't already exist
if not os.path.exists(os.path.join(env.workspace, 'csv')):
	os.makedirs(os.path.join(env.workspace, 'csv'))

# Write the stats that have been collected to a csv file
with open(os.path.join(env.workspace, 'csv/development_stats.csv'), 'wb') as dev_stats:
	csv_writer = csv.writer(dev_stats)
	for entry in stats:
		csv_writer.writerow(entry)

#------------------------------------------------------------------------------------------------
# The portion of the script below will assign each taxlot in the Portland Metro area a 'yearbuilt'
# based on which MAX station it is closest to.  This will ultimately be used to create an approximation
# of growth region wide that can be compared to growth around MAX stations

# Find the nearest MAX stop to each tax lot
# note that this dataset is created with create_isocrones.py which must be run first
stops_with_zone = os.path.join(env.workspace, 'temp/max_stops_with_zone.shp')
taxlot_near_stops = os.path.join(env.workspace, 'temp/tlots_near_max_stops.dbf')
arcpy.GenerateNearTable_analysis(taxlots, stops_with_zone, taxlot_near_stops)

# create a mapping from the taxlots fid to its nearest stop
taxlot2stops_dict = {}
fields = ['IN_FID', 'NEAR_FID']
with arcpy.da.SearchCursor(taxlot_near_stops, fields) as cursor:
	for tl_fid, stop_fid in cursor:
		taxlot2stops_dict[tl_fid] = stop_fid

# create a mapping from the fid for each stop to its inception year
stop_year_dict = {}
fields = ['OID@', 'incpt_year']
with arcpy.da.SearchCursor(stops_with_zone, fields) as cursor:
	for oid, inception_year in cursor:
		stop_year_dict[oid] = inception_year

# update taxlot2stops_dict such that the taxlot's fid maps to the inception year of its nearest MAX stop
for key, value in taxlot2stops_dict.iteritems():
	taxlot2stops_dict[key] = stop_year_dict[value]

# Create a new feature class to store a subset of taxlots
new_development = os.path.join(env.workspace, 'new_dev_taxlots.shp')
geom_type = 'POLYGON'
sr = arcpy.SpatialReference(2913)
arcpy.CreateFeatureclass_management(os.path.dirname(new_development), os.path.basename(new_development), 
										geom_type, spatial_reference=sr)

new_fields = [('TLID', 'TEXT'), ('TOTALVAL', 'LONG'), ('YEARBUILT', 'SHORT'), ('MAX_YEAR', 'SHORT')]
for f_name, f_type in new_fields:
	arcpy.AddField_management(new_development, f_name, f_type)

drop_field = 'Id'
arcpy.DeleteField_management(new_development, drop_field)

# For all taxlots that have development more recently than their nearest MAX stop was built, add them to the
# newly created feature class
fields = ['SHAPE@'] + [f_name for f_name, f_type in new_fields]
i_cursor = arcpy.da.InsertCursor(new_development, fields)

fields = ['SHAPE@', 'OID@', 'TLID', 'TOTALVAL', 'YEARBUILT']
with arcpy.da.SearchCursor(taxlots, fields) as cursor:
	for geom, oid, tlid, value, year_built in cursor:
		if year_built >= taxlot2stops_dict[oid]:
			i_cursor.insertRow((geom, tlid, value, year_built, taxlot2stops_dict[oid]))

del i_cursor


# Add datasets for next phase of project which is determing taxlots position to critical regional boundaries
ugb = '//gisstore/gis/Rlis/BOUNDARY/ugb.shp'
tm_district = '//gisstore/gis/TRIMET/tm_fill.shp'
cities = '//gisstore/gis/Rlis/BOUNDARY/cty_fill.shp'
max_tls = os.path.join(env.workspace, 'temp/taxlot_iso_dissolve.shp')
max_mfs = os.path.join(env.workspace, 'temp/multifam_iso_dissolve.shp')

# Get the geometry object for each of the cities that are to be compared against the taxlots
def getBoundaryGeom(fc):
	fields = ['OID@', 'SHAPE@']
	with arcpy.da.SearchCursor(fc, fields) as cursor:
		for oid, geom in cursor:
			return geom

ugb_geom = getBoundaryGeom(ugb)
tm_dist_geom = getBoundaryGeom(tm_district)

# I'm only interested in the 9 most populuous cities in the TM district in the case, so I need to isolate them
# and combine them into a single geometry
nine_city_geom = None
fields = ['SHAPE@', 'CITYNAME']
big_9_cities = ['Portland', 'Gresham', 'Hillsboro', 'Beaverton', 'Tualatin', 
					'Tigard', 'Lake Oswego', 'Oregon City', 'West Linn']
with arcpy.da.SearchCursor(cities, fields) as cursor:
	for geom, name in cursor:
		if name in big_9_cities:
			if nine_city_geom == None:
				nine_city_geom = geom
			else:
				nine_city_geom = nine_city_geom.union(geom)

# Create a single geometry for all of the taxlots near MAX stops
max_tl_lyr = 'max_taxlot_layer'
arcpy.MakeFeatureLayer_management(max_tls, max_tl_lyr)

max_tl_dissolve = os.path.join(env.workspace, 'temp/max_taxlot_dissolve.shp')
arcpy.Dissolve_management(max_tl_lyr, max_tl_dissolve)

max_tl_geom = None
fields = ['SHAPE@', 'OID@']
with arcpy.da.SearchCursor(max_tl_dissolve, fields) as cursor:
	for geom, oid in cursor:
		max_tl_geom = geom

# Add fields that indicate whether or not each taxlot is in the TM District, the Urban Growth Boundary
more_fields = ['TM_DIST', 'UGB', 'BIG_9', 'NEAR_MAX']
f_type = 'TEXT'
for f_name in more_fields:
	arcpy.AddField_management(new_development, f_name, f_type)

more_fields.insert(0, 'SHAPE@')
with arcpy.da.UpdateCursor(new_development, fields) as cursor:
	for geom, tm, ugb, big_9, near_max, in cursor:
		if geom.overlaps(tm_dist_geom) == True:
			tm = 'yes'
		else:
			tm = 'no'

		if geom.overlaps(ugb_geom) == True:
			ugb = 'yes'
		else:
			ugb = 'no'

		if geom.overlaps(nine_city_geom) == True:
			big_9 = 'yes'
		else:
			big_9 = 'no'

		if geom.within(max_tl_geom) == True:
			near_max = 'yes'
		else:
			near_max = 'no'

		cursor.updateRow((geom, tm, ugb, big_9, near_max))